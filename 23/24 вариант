#include <stdio.h>
#include <stdlib.h>

#define MENU \
"\n-----------------------------------\n" \
"1) Add new element\n" \
"2) Print tree\n" \
"3) Delete element\n" \
"4) Determine the depth of the tree \n" \
"5) Exit \n" \
"-----------------------------------\n" \
"\t Choose action: "

struct node
{
	struct node* father;
	struct node* brother;
	struct node* son;
	int data;
};

struct node* create(int); //создание дерева
struct node* last(struct node*); //нахождение старшего брата
struct node* findelem(struct node*, int); //нахождение заданного элемента
struct node* bro(struct node*, struct node*); //нахождение брата
void insert(struct node*, int); //добавление элемента
void printtree(struct node*, int); //вывод дерева
int deleteelem(struct node*); //удаление элемента
int treedepth(struct node*, int g); //нахождение глубины дерева
int Max(int x, int y); //функция нахождения макс значения двух переменных
int first; //корень дерева


int main()
{
	int fl = 1; //пустота дерева
	int action;
	int g = 0;
	int maxdeep = 0; //глубина дерева
	struct node* tree;
	do
    {
    	printf(MENU);
		scanf("%d", &action);
        switch (action)
        {
	        case 1: //добавление элемента
	            if (fl==1) //если дерево пустое
	            {
	            	printf("Enter new element: ");
	            	scanf("%d", &first);
	            	tree = create(first);
	            	fl = 0;
	            	g = 0;
	            }
	            else //если в дереве уже есть корень
	            {
	            	int vertex, father;
	                struct node* p;
	                printf("\nEnter a father of new element: ");
	                scanf("%d", &father);
	     			p = findelem(tree, father);
	                if (p == NULL) 
	                { 
	                   	printf("\nERROR: Can't find this father");
	                   	break;
	                }
	                else
	                {
	                	printf("\nEnter a vertex: ");
	                	scanf("%d", &vertex);
	                    insert(p, vertex);
	                }
	            }
	            break;
	        case 2: //вывод дерева
	            if (fl == 1) //если дерево пустое
	            {
	                printf("\nTree is empty\n");
	                break;
	            }
	            else //если дерево не пустое
	            {
	                printf("\nEntered tree:\n");
	             	printtree(tree, 0);
	            }
	            break;
	        case 3: //удаление узла дерева с детьми
	            if (fl == 1) //если дерево пустое
	            {
	                printf("\nTree is empty\n");
	                break;
	            }
	            printf("\nEnter a vertex to delete: "); 
	            int p;
	            scanf("%d", &p);
	            struct node* destr;
	            destr = findelem(tree, p);
	            if (destr == tree) //если все дерево - один элемент
	            {
	                free(destr);
	                fl = 1;
	                printf("Tree successfully deleted!\n");
	                break;
	            }
	            if (destr != NULL) //удаление узла с детьми
	            {
	                struct node* br;
	                br = bro(destr, (destr->father->son));
	                if (br != destr)
	                {
	                    (br->brother) = (destr->brother);
	                }
	                else
	                {
	                    ((destr->father->son) = (destr->brother));
	                    deleteelem(destr->son);
	                    free(destr);
	                }
	                printf("Element successfully deleted\n");
	            } 
				else printf("\nERROR: This element doesn't exist");
	            break;
	        case 4:
	        	if (fl == 1) //если дерево пустое
	            {
	                printf("\nTree is empty\n");
	                break;
	            }
	        	g = 0;
	        	maxdeep = 0;
	        	g = treedepth(tree, 0);
				if (g > maxdeep)
				{
					maxdeep = g;
				}
	        	printf("\nThe deepth ot the tree is:\n");
	        	printf("%d\n", maxdeep);
	        	break;
	        case 5: //выход из программы и очистка памяти под деревом
    			if (fl == 1) 
	            	break;
	            	return 0;
	            struct node* rush;
	            rush = findelem(tree, first);
	            if (rush == tree) 
	            {
	                free(rush);
	                return 0;
	            }
	            if (rush != NULL) 
	            {
	                struct node* brt;
	                brt = bro(rush, (rush->father->son));
	                if (brt != rush)
	                {
	                    (brt->brother) = (rush->brother);
	                }
	                else
	                {
	                    ((rush->father->son) = (rush->brother));
	                    deleteelem(rush->son);
	                    free(rush);
	                }
	            return 0; 
	            }

	        default: //ввод некорректной команды
	            printf("ERROR: Unknown command\n");
	            break;
	    }
	}
	while (action != -1);
}

struct node* create(int data) //создание дерева
{
        struct node* first = (struct node*) malloc(sizeof(struct node));
        (first->father) = NULL;
        (first->son) = NULL;
        (first->brother) = NULL;
        (first->data) = data;
        return first;
}

struct node* findelem(struct node* tree, int data) //поиск элемента
{
        if (tree == NULL)
            return NULL;
        if ((tree->data) == data)
            return tree;
        else 
        {
            struct node* br = findelem(tree->brother, data);
            struct node* s = findelem(tree->son, data);
            if (br != NULL)
                return br;
            else
                return s;
        }
}

struct node* last(struct node* tree) //нахождение старшего брата
{
        if (tree == NULL)
            return tree;
        if ((tree->brother) == NULL)
            return tree;
        else
            return last(tree->brother);
}

void insert(struct node* tree, int data) //добавление элемента
{
        struct node* t;
        struct node* _last;
        t = create(data);
        _last = last(tree->son);
        (t->father) = tree;
        if (_last == NULL)
            (tree->son) = t;
        else
            (_last->brother) = t;
}

void printtree(struct node* tree, int k) //печать дерева
{
    for (int i = 0; i < k; ++i)
        printf("\t");
    printf("%d\n", (tree->data));
    if ((tree->son) != NULL)
        printtree(tree->son, k + 1);
    if ((tree->brother) != NULL)
        printtree(tree->brother, k);
}

int deleteelem(struct node* tree) //удаление элемента
{
    if (tree == NULL)
       return 1;
    deleteelem(tree->brother);
    deleteelem(tree->son);
    free(tree);
    return 0;
}


struct node* bro(struct node* tree, struct node* br) //поиск ближайшего старшего брата
{
    if (br == tree)
        return br;
    if (tree == (br->brother))
        return br;
    else
        return bro(tree, (br->brother));
}

int Max(int x, int y)
{
    if (x<y)
        return y;
    else if (y<x)
    	return x;
    else
        return x;
}

int treedepth(struct node* tree, int deep)
{	
    if (!tree)
        return deep;
    else
    	return Max(treedepth(tree->brother, deep), treedepth(tree->son, deep + 1));
}
